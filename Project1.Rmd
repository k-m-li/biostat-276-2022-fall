---
title: "Biostat 276 Project 1"
author: "Kelly Li"
date: "1/29/2022"
output: pdf_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(gridExtra)
knitr::opts_chunk$set(echo = TRUE)
```

##  Sampling from the Banana Distribution

# a) 


## Bayesian Adaptive Lasso

#a) 
```{r}
sima <- rnorm(5000, 0, 1)
plot(density(sima), main = "Marginal Density")
```

# b)
```{r}
lambda2 <- 2
tau2 <- rgamma(5000, shape = 1, rate = lambda2/2)
simb <- rnorm(5000, 0, sqrt(tau2))
plot(density(simb), main = "Beta marginal")
```

# c)
\pretolerance=10000
```{r, out.width = "90%"}
bvec <- c(1, 8, 20, 10000)
marginalplot <- function(n, b){
  lambda <- 1/rgamma(n, 1, b)
  tau2 <- rgamma(n, shape = 1, rate = lambda^2/2)
  sim <- rnorm(n, 0, sqrt(tau2))
  plot <- plot(density(sim), 
               main = paste0("Beta marginal, b = ", b),
               xlim = c(-10, 10))
  save_plot <- recordPlot()
  return(save_plot)
}

plots <- lapply(bvec, marginalplot, n = 5000)

```

# d)
I will implement an MH + Gibbs Sampler algorithm to sample from the posterior distributions. 
```{r}
library(lars)
library(mvtnorm)
mh.gibbs <- function(y, X,
                     n.sim = 1000, burn = 0.1,
                     a, b, beta){
  #Chain information
  n.total <- n.sim*(1.0 + burn)
  n.burn <- n.sim*burn
  
  #Initializing matrices
  betamu.out <- matrix(NA, n.sim, 10)
  beta.out <- matrix(NA, n.sim, 10)
  sigma2.out <- c()
  
  #Data and Parameters
  n <- length(y)
  p <- ncol(X)
  XtX <- t(X) %*% X
  
  for(i in 1:n.total){
    rss <- t(y - X %*% beta)%*%(y - X %*% beta)
    #lambda2
    lambda2 <- 1/rgamma(1, a, rate = b)
    #tau2
    tau2 <- -(2/lambda2) * log(runif(10))
    #sigma2
    shape <- 0.1 + n/2
    scale <- rss/2 + 0.1
    sigma2 <- 1/rgamma(1, shape = shape, scale = scale)
    #beta
    betavar <- solve(XtX/sigma2 + solve(diag(tau2)))
    betamu <- betavar %*% t(X) %*% y/sigma2
    beta <- rmvnorm(n=1, mean = betamu, sigma = betavar) %>% t()
    if(i > n.burn){
      i1 <- i - n.burn
      betamu.out[i1, ] <- betamu
      beta.out[i1, ] <- beta
      sigma2.out[i1] <- sigma2
    }
  }
 return(list(beta = beta.out, sigma2 = sigma2.out))
}

data("diabetes")
X <- diabetes$x
y <- diabetes$y
betahat <- solve(t(X) %*% X) %*% t(X) %*% y
out <- mh.gibbs(y = y, X = X, n = 10000, burn = 0,
         a = 1, b = 1, beta = betahat)

out1 <- mh.gibbs(y = y, X = X, n = 10000, burn = 0,
         a = 1, b = 1, beta = rep(0, 10))

apply(out$beta, 2, function(x){quantile(x, c(0.025, 0.5, 0.975))})
```

```{r}
library(lars)
data("diabetes")
dia_x <- diabetes$x
dia_y <- diabetes$y
initial_value <- list(tau_sq=rep(1,10),
                      beta=rep(0,10),
                      sigma_sq=0.01,
                      lambda_sq=1)
mcmc.sim.gibbs <- function(initial_value, reg_path=F, sen_analysis=F,
                           nsim=1000, burn=0, a=1, b=2,
                           X=dia_x, Y=dia_y, seed=199609){
  set.seed(seed)
  nsim.total <- nsim*(1.0 + burn)
  burn.num <- nsim*burn
  
  tau_sq <- initial_value$tau_sq
  beta <- initial_value$beta
  sigma_sq <- initial_value$sigma_sq
  lambda_sq <- initial_value$lambda_sq
  
  beta.ch <- matrix(NA,nsim,10)
  bmean.ch <- matrix(NA,nsim,10)
  sigma_sq.ch <- vector()
  rate.ch<-vector()
  for(i in 1:nsim.total){
    #i=2
    #beta
    bmean <- solve(t(X)%*%X+diag(sigma_sq/tau_sq))%*%t(X)%*%Y
    bvar <- solve(t(X)%*%X/sigma_sq+solve(diag(tau_sq)))
    beta <- rmvnorm(n=1, mean = bmean, sigma = bvar)
    browser()
    #tau_sq
    tau_sq <- -(2/lambda_sq)*log(runif(10))
    #lambda_sq
    if(reg_path==T){
      lambda_sq <- lambda_sq
    }else if(sen_analysis==T){
      lambda_sq <- 1/rgamma(1, a, rate = b)
    }else{
      lambda_sq <- -b/log(runif(1))
    }
    #sigma_sq
    sigma_sq <- 1/rgamma(1,0.1,scale = 1/2*t(Y-X%*%t(beta))%*%(Y-X%*%t(beta))+0.1)
    if(i > burn.num){
      i1 <- i - burn.num
      bmean.ch[i1,] <- bmean
      beta.ch[i1,] <- beta
      sigma_sq.ch[i1] <- sigma_sq
      rate.ch[i1]<-1/2*t(Y-X%*%t(beta))%*%(Y-X%*%t(beta))+10
    }
  }
  return(list(beta=beta.ch, sigma_sq=sigma_sq.ch))
}

results_gibbs <- mcmc.sim.gibbs(initial_value,nsim=10000, burn=0.3, b=2)
apply(results_gibbs$beta, 2, function(x){quantile(x,c(0.025,0.5,0.975))})
```

